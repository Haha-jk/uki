
parser tokens:
    — program
    —     declaration* EOF
    
    statements: []
    index: 0

    is-at-end:
        exit tokens.index.kind = "EOF"
    
    is-current-token-kind token-type:
        exit tokens.index.kind = token-type
    
    is-next-token-kind token-type:
        exit tokens.(index - 1).kind = token-type
    
    is-previous-token-kind token-type:
        exit tokens.(index + 1).kind = token-type
    
    statement:
        — expression-statement |
        — loop-statement       |
        — when-statement       |
        — exit-statement       |
        — block
        
        when is-current-token-kind "loop"
            exit loop-statement
        then is-current-token-kind "when"
            exit when-statement
        then is-current-token-kind "exit"
            exit return-statement
        then is-current-token-kind "indent"
            exit block
        then
            exit expression-statement
    
    declaration:
        — function-declaration | 
        — variable-declaration |
        — statement
        
        when is-current-token-kind "colon" 
            when is-previous-token-kind "function-identifier"
                exit function-declaration
            then is-previous-token-kind "variable-identifier"
                exit variable-declaration
        then
            exit statement
        
    loop !is-at-end
        insert statements, declaration
        index = index + 1

    exit statements



tokens.(-1) 



calculator:
    display-value: ""
    
    append-to-display value:
        display-value = display-value | value
    
    clear-display:
        display-value = ""
    
    calculate-result:
        when
            display-value = evaluate display-value
        then
            display-value = "Error"
    

    exit <
        woman
            box-size-x: 320
            box-colour: colours.white
            box-inner: 20
            box-corner: 10
            box-shadow: 0 4 10 rgba(0, 0, 0, 0.2)
        
            input
                input-type: "text"
                input-editable: wrong
                input-value::display-value
                text-align: right
                text-size: 28
                box-size-x: 100%
                box-size-y: 60
                box-inner: 10
                box-outer-y-max: 10
                box-colour: #eee
                box-corner: 5
                
            woman
                display: grid
                grid-template-columns: repeat(4, 1fr)
                gap: 8
                
                button:
                    box-size-y: 60
                    box-colour: "#ddd"
                    box-corner: 5
                    text-size: 22
                    cursor-type: "pointer"
                    transition: ["box.colour", "0.2s"]
                    state-active: {self.box-colour: "#bbb"}
                    event-click: {append-to-display self.text-content}
                
                white-text:
                    text-colour: colours.white
                
                operator: white-text
                    box-colour: colours.blue
                
                button
                    text-content: "7"
                button 
                    text-content: "8"
                button 
                    text-content: "9"
                button operator
                    text-content: "/"
        
                button 
                    text-content: "4"
                button 
                    text-content: "5"
                button 
                    text-content: "6"
                button operator
                    text-content: "*"
        
                button 
                    text-content: "1"
                button 
                    text-content: "2"
                button 
                    text-content: "3"
                button operator
                    text-content: "-"
        
                button white-text
                    text-content: "C"
                    event-click: {clear-display}
                    box-colour: "#dc3545"
                button 
                    text-content: "0"
                button white-text
                    text-content: "="
                    event-click: {calculate-result}
                    box-colour: "#dc3545"
                button operator
                    text-content: "+"
    >


render <
    origin
        meta-title: "Calculator"
        text-fonts: ["Arial", "sans-serif"]
        box-colour: "#f4f4f4"
        
        calculator
>











is-prime num:
    when num !> 1
        exit wrong
    then num = 2
        exit right
    then (remainder num, 2) = 0
        exit wrong

    loop 3_(power num, 0.5)_2 with i
        when (remainder num, i) = 0
            exit wrong

    exit right


print-prime num-1, num-2: 
    write "Prime numbers from |num-1| to |num2| are:"
    
    loop num-1_num-2 with num
        when is-prime num
            write num


num-1: to-number prompt "What is your 1st number" 
num-2: to-number prompt "What is your 2nd number"

print-prime num-1, num-2





function isPrime(num) {
    if (num <= 1) return false;
    if (num === 2) return true;
    if (num % 2 === 0) return false;

    // Loop to check divisibility from 3 to the square root of num
    for (let i = 3; i <= Math.sqrt(num); i += 2) {
        if (num % i === 0) return false;
    }

    return true;
}

function printPrimes(num1, num2) {
    console.log(`Prime numbers from ${num1} to ${num2} are:`);

    for (let num = num1; num <= num2; num++) {
        if (isPrime(num)) {
            console.log(num);
        }
    }
}

const num1 = parseInt(prompt("What is your 1st number"));
const num2 = parseInt(prompt("What is your 2nd number"));

printPrimes(num1, num2);













I'm building a lexer for a Python-like language where:  
1. **No explicit statement terminators** (like semicolons).  
2. **Indentation defines blocks** (using `Indent`/`Dedent` tokens).  
3. **Colon `:` is for assignment**, not block headers (unlike Python).  
4. **No line continuations** (backslash `\` or implicit bracket-based).  

**Current Lexer Behavior:**  
- Tokenizes keywords, identifiers, literals, and operators.  
- Uses `Indent`/`Dedent` for blocks (like Python).  
- **Problem:** Missing clear "end of statement" detection.  

**What I Need:**  
- A way to **denote statement boundaries** without semicolons or Python-style `:` blocks.  
- Should work with:  
  - Assignment (`x: 10` → `[Identifier(x), Colon, NumericLiteral(10), <END>]`)  
  - Control flow (`if x > 5` → `[IfKeyword, Identifier(x), MoreThan, NumericLiteral(5), <END>]`)  
  - Nested blocks (via `Indent`/`Dedent`, no `:` triggers).  

**Constraints:**  
- **No statement continuations** (no backslash `\` or bracket-based newline ignoring).  
- **No Python-style `:` blocks** (colon is purely for assignment).  

**Additional Context (Lexer Code):**  
```nim

import tables
import types


proc lexer*(input: string): LexerOutput =
    var index: int
    var tokens: Tokens
    var diagnostics: Diagnostics
    var line: int = 1
    var indentStack = @[0]

    proc addToken(tokenKind: TokenKind, lexeme: string = "") =
        add tokens, Token(tokenKind: tokenKind, lexeme: lexeme, line: line)
    
    proc addDiagnostic(errorMessage: string) =
        add diagnostics, Diagnostic(diagnosticKind: DiagnosticKind.Lexer, errorMessage: errorMessage, line: line)
    
    proc isAtEnd(): bool =
        return index >= input.len

    proc isDigit(character: char): bool =
        return character in {'0' .. '9'}

    proc isAlphabet(character: char): bool =
        return character in {'a'..'z'}
    
    proc isAlphaNumeric(character: char): bool =
        return isAlphabet(character) or isDigit(character) or character == '-'
    
    
    proc string() =
        # Skip the opening quote
        index.inc()  
        var accumulate = ""
        while true:
            if isAtEnd():
                addDiagnostic("Unterminated string literal")
                return
    
            if input[index] == '"':
                break
            elif input[index] == '\n':
                line.inc()
    
            accumulate &= $input[index]
            index.inc()
    
        # Skip the closing quote
        index.inc()  
        addToken(TokenKind.StringLiteral, accumulate)
    
    proc identifier() =
        var accumulate = ""
        while not isAtEnd() and isAlphaNumeric(input[index]):
            accumulate &= $input[index]
        
            index.inc()
        
        const keywords = {
            "try": TokenKind.TryKeyword,
            "fix": TokenKind.FixKeyword,
            "when": TokenKind.WhenKeyword,
            "then": TokenKind.ThenKeyword,
            "loop": TokenKind.LoopKeyword,
            "with": TokenKind.WithKeyword,
            "right": TokenKind.RightKeyword,
            "wrong": TokenKind.WrongKeyword,
            "import": TokenKind.ImportKeyword,
            "export": TokenKind.ExportKeyword
        }.toTable
        
        # Check if the identifier is a keyword
        if keywords.hasKey(accumulate):
            addToken(keywords[accumulate], accumulate)  
        else:
            addToken(TokenKind.Identifier, accumulate) 


    proc number(isNegative: bool = false) =
        var accumulate = if isNegative: "-" else: ""
        while not isAtEnd() and isDigit(input[index]):
            accumulate &= input[index]
            index.inc()

        addToken(TokenKind.NumericLiteral, accumulate)
    
    proc handleIndentation() =
        var spaceCount = 0
    
        # Count leading spaces
        while not isAtEnd() and input[index] == ' ':
            spaceCount.inc()
            index.inc()
    
        # Skip line if it's empty or contains only spaces
        if isAtEnd() or input[index] == '\n':
            return
    
        # Indentation must be a multiple of 4
        if spaceCount mod 4 != 0:
            addDiagnostic("Indentation must be a multiple of 4 spaces")
            return
    
        let indentLevel = spaceCount div 4
        let currentIndentLevel = indentStack[^1]
    
        if indentLevel > currentIndentLevel:
            # Only allow increasing by one level at a time
            if indentLevel != currentIndentLevel + 1:
                addDiagnostic("Unexpected indent level: expected " &
                    $(currentIndentLevel + 1) & " but got " & $indentLevel)
                return
            indentStack.add(indentLevel)
            addToken(TokenKind.Indent)
    
        elif indentLevel < currentIndentLevel:
            # Dedent to known indentation level
            while indentStack.len > 0 and indentStack[^1] > indentLevel:
                indentStack.setLen(indentStack.len - 1)
                addToken(TokenKind.Dedent)
    
            if indentStack.len == 0 or indentStack[^1] != indentLevel:
                addDiagnostic("Inconsistent dedent: expected indent level " &
                    $indentStack[^1] & " but got " & $indentLevel)

    while not isAtEnd():
        let character = input[index]
        
        case character
        of '(':
            addToken(TokenKind.LeftRoundBracket, $character)
            index.inc()
        of ')':
            addToken(TokenKind.RightRoundBracket, $character)
            index.inc()
        of '{':
            addToken(TokenKind.LeftCurlyBracket, $character)
            index.inc()
        of '}':
            addToken(TokenKind.RightCurlyBracket, $character)
            index.inc()
        of '[':
            addToken(TokenKind.LeftSquareBracket, $character)
            index.inc()
        of ']':
            addToken(TokenKind.RightSquareBracket, $character)
            index.inc()
        of ',':
            addToken(TokenKind.Comma, $character)
            index.inc()
        of '.':
            addToken(TokenKind.Dot, $character)
            index.inc()
        of ':':
            addToken(TokenKind.Colon, $character)
            index.inc()
        of '-':
            if index + 1 < input.len and isDigit(input[index + 1]):
                index.inc()
                number(true)
            else:
                addToken(TokenKind.Minus, $character)
                index.inc()
        of '+':
            if index + 1 < input.len and isDigit(input[index + 1]):
                index.inc()
                number()
            else:
                addToken(TokenKind.Plus, $character)
                index.inc()
        of '*':
            addToken(TokenKind.Asterisk, $character)
            index.inc()
        of '/':
            addToken(TokenKind.Slash, $character)
            index.inc()
        of '$':
            addToken(TokenKind.Dollar, $character)
            index.inc()
        of '?':
            addToken(TokenKind.Question, $character)
            index.inc()
        of '&':
            addToken(TokenKind.Ampersand, $character)
            index.inc()
        of '=':
            addToken(TokenKind.Equal, $character)
            index.inc()
        of '>':
            addToken(TokenKind.MoreThan, $character)
            index.inc()
        of '<':
            addToken(TokenKind.LessThan, $character)
            index.inc()
        of '|':
            addToken(TokenKind.Bar, $character)
            index.inc()
        of '#':
            # Ignore single line comment
            while not isAtEnd() and not (input[index] == '\n'):
                index.inc()
        of '_':
            if index + 1 < input.len and input[index + 1] == '<':
                index.inc(2)
                addToken(TokenKind.UnderscoreLessThan, "_<")
            else:
                addToken(TokenKind.Underscore, $character)
                index.inc()
        of '\n':
            line.inc()
            index.inc()
            handleIndentation()
        of ' ', '\\':
            index.inc()
        of '!':
            if index + 1 < input.len:
                if input[index + 1] == '=':
                    addToken(TokenKind.ExclamationEqual, "!=")
                    index.inc(2)
                elif input[index + 1] == '>':
                    addToken(TokenKind.ExclamationMoreThan, "!>")
                    index.inc(2)
                elif input[index + 1] == '<': 
                    addToken(TokenKind.ExclamationLessThan, "!<")
                    index.inc(2)
            else: 
                addToken(TokenKind.Exclamation, $character)
                index.inc()
        of '"':
            string()
        else:
            if isDigit(character):
                number()
            elif isAlphabet(character):
                identifier()
            else:
                addDiagnostic("Unexpected character: `" & $character & "`")
                index.inc()

    while indentStack.len > 1:  
        indentStack.setLen(indentStack.len - 1)
        addToken(TokenKind.Dedent)
    
    addToken(TokenKind.EndOfFile)
    
    return LexerOutput(
        diagnostics: diagnostics, 
        input: input, 
        tokens: tokens
    )

```
sample code from my programming language 
```uki
is-prime num:
    when num !> 1
        exit wrong
    then num = 2
        exit right
    then (remainder num, 2) = 0
        exit wrong

    loop 3_(power num, 0.5)_2 with i
        when (remainder num, i) = 0
            exit wrong

    exit right


print-prime num-1, num-2: 
    write "Prime numbers from |num-1| to |num2| are:"
    
    loop num-1_num-2 with num
        when is-prime num
            write num


num-1: to-number prompt "What is your 1st number" 
num-2: to-number prompt "What is your 2nd number"

print-prime num-1, num-2

```
**Key Questions for New LLM:**  
1. How should `Newline` tokens be used to mark statement ends **without** Python's colon-based rules?  
2. How to handle **empty lines** or **comments** (should they generate `Newline` tokens)?  
3. Should `Indent` always follow a `Newline` (or can it appear mid-line)?  

**Primary Goal (MOST IMPORTANT):** A **simple, predictable** way to detect statement ends in a whitespace-sensitive language for keeping the **PARSER disambigous**


